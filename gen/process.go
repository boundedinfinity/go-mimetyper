package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"io/ioutil"
	"os"
	"strings"
	"text/template"

	"github.com/boundedinfinity/optioner"
	"gopkg.in/yaml.v3"
)

type data struct {
	Description   optioner.Option[string] `json:"description" yaml:"description"`
	MimeType      string                  `json:"mime-type" yaml:"mime-type"`
	MimeTypeAlt   []string                `json:"mime-type-alt" yaml:"mime-type-alt"`
	FileExtention []string                `json:"file-extention" yaml:"file-extention"`
}

type byMimeType []data

func (t byMimeType) Len() int      { return len(t) }
func (t byMimeType) Swap(i, j int) { t[i], t[j] = t[j], t[i] }
func (t byMimeType) Less(i, j int) bool {
	return t[i].MimeType < t[j].MimeType
}

const (
	dataYaml            = "gen/data.yaml"
	mimeTypeMainGo      = "mime_type/main.go"
	fileExtentionMainGo = "file_extention/main.go"
	fileExtentionMapGo  = "file_extention/map.go"
	indent              = 4
)

func main() {
	var data []data

	if err := readDataYaml(&data); err != nil {
		handleError(err)
	}

	if err := process2(data); err != nil {
		handleError(err)
	}
}

func process2(data []data) error {
	header := `
//************************************************************************************
//*                                                                                  *
//* ===== DO NOT EDIT =====                                                          *
//* Any change will be overwritten                                                   *
//* Generated by gen/process.go                                                      *
//*                                                                                  *
//************************************************************************************
	`
	mimeTypeType := header + `
    package mime_type

	type MimeType string

    const (        
	{{ range $i := . }}
		{{ goName $i.MimeType }} MimeType = "{{ $i.MimeType }}"
	{{- end }}
    )
    `

	if err := writeTemplate(mimeTypeMainGo, mimeTypeType, data); err != nil {
		return fmt.Errorf("%v : %w", mimeTypeMainGo, err)
	}

	fileExtentionType := header + `
    package file_extention

	type FileExtention string
    
    const (
	{{ range $i := . }}
	{{- range $e := $i.FileExtention }}
		{{ goName $e }} FileExtention = "{{ $e }}"
	{{- end }}	
	{{- end }}
    )
    `

	if err := writeTemplate(fileExtentionMainGo, fileExtentionType, data); err != nil {
		return fmt.Errorf("%v : %w", fileExtentionMainGo, err)
	}

	fileExtention2MimeType := header + `
    package file_extention

	import "github.com/boundedinfinity/mimetyper/mime_type"

	var (
		m = map[FileExtention]mime_type.MimeType{
	{{- range $i := . }}
	{{- range $e := $i.FileExtention }}
		{{ goName $e }}:  mime_type.{{ goName $i.MimeType }},
	{{- end }}	
	{{- end }}
		}
    )
    `

	if err := writeTemplate(fileExtentionMapGo, fileExtention2MimeType, data); err != nil {
		return fmt.Errorf("%v : %w", fileExtentionMapGo, err)
	}

	return nil
}

var replaceChars = []string{"/", "-", ".", "+"}
var numChars = []string{"0", "1", "2", "3", "4", "5", "6", "7", "8", "9"}

func goName(s string) string {
	n := s

	for _, r := range replaceChars {
		n = strings.ReplaceAll(n, r, " ")
	}

	n = strings.TrimSpace(n)

	for _, x := range numChars {
		if strings.HasPrefix(n, x) {
			n = "_" + n
		}
	}

	n = strings.Title(n)
	n = strings.ReplaceAll(n, " ", "")

	return n
}

func writeTemplate(p, t string, data []data) error {
	tmpl, err := template.New("").Funcs(template.FuncMap{
		"goName": goName,
	}).Parse(t)

	if err != nil {
		return err
	}

	var buffer bytes.Buffer

	if err := tmpl.Execute(&buffer, data); err != nil {
		return err
	}

	bs := buffer.Bytes()
	bs, err = format.Source(bs)

	if err != nil {
		return err
	}

	file, err := os.OpenFile(p, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)

	if err != nil {
		return err
	}

	defer file.Close()

	out := bufio.NewWriter(file)
	defer out.Flush()

	out.WriteString(string(bs))

	return nil
}

func readDataYaml(vs *[]data) error {
	bs, err := ioutil.ReadFile(dataYaml)

	if err != nil {
		return err
	}

	if err := yaml.Unmarshal(bs, &vs); err != nil {
		return err
	}

	return nil
}

func handleError(err error) {
	fmt.Print(err.Error())
	os.Exit(1)
}
