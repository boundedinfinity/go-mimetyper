package main

import (
	"bufio"
	"bytes"
	"fmt"
	"go/format"
	"os"
	"text/template"

	"github.com/boundedinfinity/enumer"
	"github.com/boundedinfinity/go-commoner/functional/optioner"
	"github.com/boundedinfinity/go-commoner/idiomatic/caser"
	"github.com/boundedinfinity/go-commoner/idiomatic/langer"
	"github.com/boundedinfinity/go-commoner/idiomatic/slicer"
	"gopkg.in/yaml.v3"
)

type record struct {
	Description   optioner.Option[string] `json:"description" yaml:"description"`
	MimeType      string                  `json:"mime-type" yaml:"mime-type"`
	MimeTypeAlt   []string                `json:"mime-type-alt" yaml:"mime-type-alt"`
	FileExtention []string                `json:"file-extention" yaml:"file-extention"`
	Translations  map[string]string       `json:"translations" yaml:"translations"`
}

var (
	dataYaml              = "gen/data.yaml"
	mimeTypeMainYaml      = "mime_type/mime-type.enum.yaml"
	mimeTypeAltMapGo      = "mime_type/map.gen.go"
	fileExtentionMainYaml = "file_extention/file-extention.enum.yaml"
	fileExtentionMapGo    = "file_extention/map.gen.go"
	translations          = map[string]string{
		"/": " ",
		".": " ",
		"-": " ",
		"+": " ",
	}
)

func main() {
	var records []record

	if err := readDataYaml(&records); err != nil {
		handleError(err)
	}

	if err := createEnumer(records); err != nil {
		handleError(err)
	}

	if err := process2(records); err != nil {
		handleError(err)
	}
}

func mime2phrase(name string) string {
	name = langer.Go.MustIdentifierWithTranslation(name, translations)
	name = caser.PascalToPhrase(name)
	return name
}

func createEnumer(records []record) error {
	mimeTypeEnum := enumer.EnumData{
		Overwrite: true,
	}

	for _, record := range records {

		mimeTypeEnum.Values = append(mimeTypeEnum.Values, enumer.EnumValue{
			Name:       mime2phrase(record.MimeType),
			Desc:       record.Description.Get(),
			Serialized: record.MimeType,
			Translate:  translations,
		})

		for _, alt := range record.MimeTypeAlt {
			mimeTypeEnum.Values = append(mimeTypeEnum.Values, enumer.EnumValue{
				Name:       mime2phrase(alt),
				Desc:       record.Description.Get(),
				Serialized: alt,
				Translate:  translations,
			})
		}
	}

	mimeTypeEnum.Values = slicer.SortFn(
		func(v enumer.EnumValue) string { return v.Name },
		mimeTypeEnum.Values...,
	)

	if err := writeYaml(mimeTypeMainYaml, mimeTypeEnum); err != nil {
		return err
	}

	fileExtEnum := enumer.EnumData{
		Overwrite: true,
	}

	for _, record := range records {
		for _, ext := range record.FileExtention {
			fileExtEnum.Values = append(fileExtEnum.Values, enumer.EnumValue{
				Name:       mime2phrase(ext),
				Desc:       record.Description.Get(),
				Serialized: ext,
				Translate:  translations,
			})
		}
	}

	fileExtEnum.Values = slicer.SortFn(
		func(v enumer.EnumValue) string { return v.Name },
		fileExtEnum.Values...,
	)

	if err := writeYaml(fileExtentionMainYaml, fileExtEnum); err != nil {
		return err
	}

	return nil
}

func writeYaml(name string, data any) error {
	bs, err := yaml.Marshal(data)

	if err != nil {
		return err
	}

	err = os.WriteFile(name, bs, os.FileMode(0755))

	return err
}

func process2(records []record) error {
	header := `
//************************************************************************************
//*                                                                                  *
//* ===== DO NOT EDIT =====                                                          *
//* Any change will be overwritten                                                   *
//* Generated by gen/process.go                                                      *
//*                                                                                  *
//************************************************************************************
	`

	mimeTypeAlt2MimeType := header + `
    package mime_type

	var (
		m = map[MimeType]MimeType{
		{{- range $i := . }}
			MimeTypes.{{ goName $i.MimeType }}: MimeTypes.{{ goName $i.MimeType }}, // {{ .Description.Get }}
		{{- range $a := $i.MimeTypeAlt }}
			MimeTypes.{{ goName $a }}: MimeTypes.{{ goName $i.MimeType }}, // {{  $i.Description.Get }}
		{{- end }}
		{{- end }}
		}
    )
    `

	if err := writeTemplate(mimeTypeAltMapGo, mimeTypeAlt2MimeType, records, true); err != nil {
		return fmt.Errorf("%v : %w", mimeTypeMainYaml, err)
	}

	fileExtention2MimeType := header + `
    package file_extention

	import "github.com/boundedinfinity/go-mimetyper/mime_type"

	var (
		ext2mt = map[FileExtention]mime_type.MimeType{
	{{- range $i := . }}
	{{- range $e := $i.FileExtention }}
		FileExtentions.{{ goName $e }}:  mime_type.MimeTypes.{{ goName $i.MimeType }}, // {{ $i.Description.Get }}
	{{- end }}	
	{{- end }}
		}

		mt2ext = map[mime_type.MimeType][]FileExtention{
	{{- range $i := . }}
			mime_type.MimeTypes.{{ goName $i.MimeType }}: {
	{{- range $e := $i.FileExtention }}
				FileExtentions.{{ goName $e }}, // {{ $i.Description.Get }}
	{{- end }}
			},
	{{- end }}
		}
    )
    `

	if err := writeTemplate(fileExtentionMapGo, fileExtention2MimeType, records, true); err != nil {
		return fmt.Errorf("%v : %w", fileExtentionMapGo, err)
	}

	return nil
}

func goName(s string) string {
	return langer.Go.MustIdentifierWithTranslation(s, translations)
}

func option(s optioner.Option[string]) string {
	return s.Get()
}

func writeTemplate(p, t string, data []record, source_format bool) error {
	tmpl, err := template.New("").Funcs(template.FuncMap{
		"goName": goName,
		"option": option,
	}).Parse(t)

	if err != nil {
		return err
	}

	var buffer bytes.Buffer

	if err := tmpl.Execute(&buffer, data); err != nil {
		return err
	}

	bs := buffer.Bytes()

	if source_format {
		bs, err = format.Source(bs)

		if err != nil {
			return err
		}
	}

	file, err := os.OpenFile(p, os.O_RDWR|os.O_CREATE|os.O_TRUNC, 0755)

	if err != nil {
		return err
	}

	defer file.Close()

	out := bufio.NewWriter(file)
	defer out.Flush()

	out.WriteString(string(bs))

	return nil
}

func readDataYaml(vs *[]record) error {
	bs, err := os.ReadFile(dataYaml)

	if err != nil {
		return err
	}

	if err := yaml.Unmarshal(bs, &vs); err != nil {
		return err
	}

	return nil
}

func handleError(err error) {
	fmt.Print(err.Error())
	os.Exit(1)
}
